<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <title>Five in a Row</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
  <nav>
    <a href="index.html" class="logo">Bianca</a>
    <div class="nav-links">
      <a href="#about">About</a>
      <a href="#projects">Projects</a>
      <a href="#contact">Contact</a>
    </div>
  </nav>

    <div id="Game">
        <div id="gameMessage" style="text-align:center; margin:10px; font-size:24px;"></div>
        <div id="restartBtn" class="restartBox">Restart Game</div>
        <canvas id="myCanvas" width="760" height="760"></canvas>
    </div>

    <script>
        const canvas = document.getElementById("myCanvas");
        const ctx = canvas.getContext("2d");
        const dotRadius = 10;
        const gridSize = 19;
        const padding = 40;
        const cellSize = (canvas.width - 2 * padding) / gridSize;
        const maxPieces = (gridSize + 1) * (gridSize + 1);
        const gameMessage = document.getElementById("gameMessage");
        const restartBtn = document.getElementById("restartBtn");

        let gameOver = false;
        let endMessage = "";
        let dots = [];
        let currentPlayer = "black";

        canvas.addEventListener("click", click);

        function drawGrid() {
            ctx.strokeStyle = "#ccc";
            ctx.lineWidth = 1;

            for (let i = 0; i <= gridSize; i++) {
                const pos = padding + i * cellSize;

                // vertical line
                ctx.beginPath();
                ctx.moveTo(pos, padding);
                ctx.lineTo(pos, canvas.height - padding);
                ctx.stroke();

                // horizontal line
                ctx.beginPath();
                ctx.moveTo(padding, pos);
                ctx.lineTo(canvas.width - padding, pos);
                ctx.stroke();
            }
        }

        function click(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            let col = Math.round((x - padding) / cellSize);
            let row = Math.round((y - padding) / cellSize);
            if (col < 0) col = 0;
            if (col > gridSize) col = gridSize;
            if (row < 0) row = 0;
            if (row > gridSize) row = gridSize;

            const alreadyExists = dots.some(d => d.row === row && d.col === col);

            if (!alreadyExists) {
                dots.push({ row, col, color: currentPlayer });
                // win
                if (checkWin(row, col, currentPlayer)) {
                endGame(currentPlayer.toUpperCase() + " wins!");
                // tie
                } else if (dots.length === maxPieces) {
                    endGame("It's a tie!");
                } else {
                    // switch player
                    if (currentPlayer === "black") {
                        currentPlayer = "white";
                    } else {
                        currentPlayer = "black";
                    }
                    draw();
                }
            }
        }

        function endGame(message) {
            gameOver = true;
            endMessage = message;
            draw(); // redraw with overlay
        }

        restartBtn.addEventListener("click", () => {
            // reset
            dots = [];
            currentPlayer = "black";
            gameMessage.textContent = "";
            restartBtn.style.display = "none";
            
            canvas.addEventListener("click", click);

            draw();
        });


        function checkWin(row, col, color) {
            const directions = [
                { dr: 0, dc: 1 },  // horizontal
                { dr: 1, dc: 0 },  // vertical
                { dr: 1, dc: 1 },  // diagonal down-right
                { dr: 1, dc: -1 }  // diagonal down-left
            ];

            for (const {dr, dc} of directions) {
                let count = 1;

                // check forward
                for (let i = 1; i < 5; i++) {
                    if (dots.some(d => d.row === row + dr*i && d.col === col + dc*i && d.color === color)) {
                        count++;
                    } else break;
                }

                // check backward
                for (let i = 1; i < 5; i++) {
                    if (dots.some(d => d.row === row - dr*i && d.col === col - dc*i && d.color === color)) {
                        count++;
                    } else break;
                }

                if (count >= 5) return true;
            }

            return false;
        }


        function drawDots() {
            for (const d of dots) {
                ctx.beginPath();
                ctx.arc(
                    padding + d.col * cellSize,
                    padding + d.row * cellSize,
                    dotRadius,
                    0,
                    Math.PI * 2
                );
                ctx.fillStyle = d.color;
                ctx.fill();
                ctx.closePath();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawDots();

            if (gameOver) {
                // semi-transparent overlay
                ctx.fillStyle = "rgba(0,0,0,0.5)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // message text
                ctx.fillStyle = "white";
                //ctx.font = "48px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(endMessage, canvas.width / 2, canvas.height / 2);

                // restart hint
                //ctx.font = "24px Arial";
                ctx.fillText("Press Restart to play again", canvas.width / 2, canvas.height / 2 + 50);
            }
        }
        draw();

    </script>
  </body>
</html>